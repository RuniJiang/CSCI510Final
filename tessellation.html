<html>

<head>
    <title>CSCI-510: Tessellation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.4.0/gl-matrix.js"></script>

    <!-- vertex Shader -->
    <script id="vertex-shader" type="x-shader/x-vertex">
        #version 300 es
        in vec4 aVertexPosition;
        in vec3 bary;
        in vec4 aNormal;
        in vec3 rotation;
        in vec3 aColor;

        uniform vec3 theta;
        uniform mat4 uProjectionMatrix;
        uniform mat4 uViewMatrix;
        uniform vec3 uLightDirection;

        out vec3 vbc;
        out vec4 vNormal;
        out vec3 vLightDirection;
        out vec3 vColor;

        void main()
        {
            // Compute the sines and cosines of each rotation
            // about each axis
            vec3 angles = radians( theta );
            vec3 c = cos( angles );
            vec3 s = sin( angles );

            // rotation matrices
            mat4 rx = mat4 ( 1.0,  0.0,  0.0,  0.0,
                             0.0,  c.x,  s.x,  0.0,
                             0.0, -s.x,  c.x,  0.0,
                             0.0,  0.0,  0.0,  1.0 );

            mat4 ry = mat4 ( c.y,  0.0, -s.y,  0.0,
                             0.0,  1.0,  0.0,  0.0,
                             s.y,  0.0,  c.y,  0.0,
                             0.0,  0.0,  0.0,  1.0 );

            mat4 rz = mat4 ( c.z,  s.z,  0.0,  0.0,
                            -s.z,  c.z,  0.0,  0.0,
                             0.0,  0.0,  1.0,  0.0,
                             0.0,  0.0,  0.0,  1.0 );

            mat4 modelMatrix = rz * ry * rx;
            mat4 modelViewMatrix = uViewMatrix * modelMatrix;

            gl_Position = uProjectionMatrix * modelViewMatrix * aVertexPosition;
            vbc = bary;

            // Transform the normal using the transpose of the inverse of the model matrix
            // mat3 normalMatrix = transpose(inverse(mat3(modelMatrix)));
            //vNormal = normalize(normalMatrix * aNormal);

            // Transform the normal using the transpose of the inverse of the model matrix
            mat4 normalMatrix = transpose(inverse((modelMatrix)));
        


            //Additional rotation matrix for normals
            //mat3 normalRotationMatrix = mat3(
            //    cos(radians(rotation.y)) * cos(radians(rotation.z)), -cos(radians(rotation.x)) * sin(radians(rotation.z)) + sin(radians(rotation.x)) * sin(radians(rotation.y)) * cos(radians(rotation.z)), sin(radians(rotation.x)) * sin(radians(rotation.z)) + cos(radians(rotation.x)) * sin(radians(rotation.y)) * cos(radians(rotation.z)),
            //    cos(radians(rotation.y)) * sin(radians(rotation.z)), cos(radians(rotation.x)) * cos(radians(rotation.z)) + sin(radians(rotation.x)) * sin(radians(rotation.y)) * sin(radians(rotation.z)), -sin(radians(rotation.x)) * cos(radians(rotation.z)) + cos(radians(rotation.x)) * sin(radians(rotation.y)) * sin(radians(rotation.z)),
            //    -sin(radians(rotation.y)), sin(radians(rotation.x)) * cos(radians(rotation.y)), cos(radians(rotation.x)) * cos(radians(rotation.y))
            //);
            
            // Apply additional rotation to the normals
            vNormal = normalize(normalMatrix * aNormal);
            //vNormal = normalize(normalRotationMatrix * normalMatrix * aNormal);

            //Pass color buffer to fragement shader
            vColor = aColor;

            vLightDirection = -normalize(uViewMatrix * vec4(uLightDirection, 0.0)).xyz;
        }
    </script>

    <!-- fragment Shader -->
    <script id="fragment-shader" type="x-shader/x-fragment">
        #version 300 es
        precision mediump float;
         
         in vec3 vbc;
         in vec4 vNormal;
         in vec3 vLightDirection;
         in vec3 vColor;

        // Color that is the result of this shader
        out vec4 fragColor;

        void main(void) {

            // Normal test
            //fragColor = vec4(vNormal, 1.0);

           // Lighting
           // Calculate the dot product between the normal and light direction
            float diffuseFactor = max(dot(normalize(vNormal.xyz), normalize(vLightDirection)), 0.0);
       
           // Set the color based on the dot product
           fragColor = vec4(vColor.x * diffuseFactor, vColor.y * diffuseFactor, vColor.z * diffuseFactor, 1.0);
         }

     </script>

    <!-- include the shape creation functions -->
    <script type="text/javascript" src="./cgIShape.js"></script>

    <!-- include the main tesselation functions -->
    <script type="text/javascript" src="./tessMain.js"></script>
    
    <!-- include the main tesselation functions -->
    <script type="text/javascript" src="./camera.js"></script>
    
    <!-- keyboard functions -->
    <script type="text/javascript">

        function gotKey(event) {

            var key = event.key;
            console.log(key);
            // ArrowUp, ArrowDown, ArrowLeft, ArrowRight

            //  incremental rotation
            if (key == 'x')
                angles[0] -= angleInc;
            else if (key == 'y' || key == 'ArrowLeft')
                angles[1] -= angleInc;
            else if (key == 'z')
                angles[2] -= angleInc;
            else if (key == 'X')
                angles[0] += angleInc;
            else if (key == 'Y' || key == 'ArrowRight')
                angles[1] += angleInc;
            else if (key == 'Z')
                angles[2] += angleInc;

        // shape selection
        else if (key == '1' || key == 'c') {
            curShape = CUBE;
        }
        else if (key == '2' || key == 'C') {
            curShape = CYLINDER;
        }
        else if (key == '3' || key == 'n') {
            curShape = CONE;
        }
        else if (key == '4') {
            curShape = SPHERE
        }
        else if (key == '5' || key == 't') {
            curShape = STAR
        }
        else if (key == '6') {
            curShape = ARCH
        }

            // tessellation control
            else if (key == '+') {
                division1 = division1 + 1;
            }
            else if (key == '=') {
                division2 = division2 + 1;
            }
            else if (key == '-') {
                if (division1 > 1) {
                    division1 = division1 - 1;
                }
            }
            else if (key == '_') {
                if (division2 > 1) {
                    division2 = division2 - 1;
                }
            }

        // reset
        else if (key == 'r' || key=='R') {
            angles[0] = anglesReset[0];
            angles[1] = anglesReset[1];
            angles[2] = anglesReset[2];
        }

        else if ( key == 'w') {
            moveForward();
        }

        else if (key == 's') {
            moveBackwards();
        }

        else if (key == 'd') {
            moveRight();
        }

        else if (key == 'a') {
            moveLeft();
        }

        else if (key == 'Shift') {
            moveUp();
        }

        else if (key == 'Control') {
            moveDown();
        }

        else if (key == 'ArrowUp') {
            lookUp();
        }

        else if (key == 'ArrowDown') {
            lookDown();
        }

        else if (key == ' ') {
            console.log("turnAround");
            turnAround();
        }

        console.log(key)
        
        // create a new shape and do a redo a draw
        createScene();
        draw();
    }
    
    </script>

    <script type="text/javascript">
        // Call init once the webpage has loaded
        window.onload = init;
    </script>
</head>

<body>
    <h1>CSCI-510: Tessellation</h1>
    <table>
        <tr>
            <td><canvas id="webgl-canvas" width="800" height="500">
                    Your browser does not support the HTML5 canvas element.
                </canvas></td>

            <td>
                <h3>Controls</h3>

                <table border="1">
                    <tbody>
                        <tr>
                            <td>x, y, z</td>
                            <td>Rotate the current shape forward about the x, y, or z axis</td>
                        </tr>
                        <tr>
                            <td>X, Y, Z</td>
                            <td>Rotate the current shape backward about the x, y, or z axis</td>
                        </tr>
                        <tr>
                            <td>1, c</td>
                            <td>Select the cube as the current shape (using current tessellation settings)</td>
                        </tr>
                        <tr>
                            <td>2, C</td>
                            <td>Select the cylinder as the current shape (using current tessellation settings)</td>
                        </tr>
                        <tr>
                            <td>3, n</td>
                            <td>Select the cone as the current shape (using current tessellation settings)</td>
                        </tr>
                        <tr>
                            <td>4, s</td>
                            <td>Select the sphere as the current shape (using current tessellation settings)</td>
                        </tr>
                        <tr>
                            <td>5, t</td>
                            <td>Select the STAR as the current shape (using current tessellation settings)</td>
                        </tr>
                        <tr>
                            <td>6, a</td>
                            <td>Select the Arch as the current shape (using current tessellation settings)</td>
                        </tr>
                        <tr>
                            <td>+, -</td>
                            <td>Increment/decrement the primary subdivision of the current shape by 1</td>
                        </tr>
                        <tr>
                            <td>=, _</td>
                            <td>Increment/decrement the secondary subdivision of the current shape by 1</td>
                        </tr>
                        <tr>
                            <td>r, R</td>
                            <td>Reset the figure to its original orientation</td>
                        </tr>
                    </tbody>
                </table>

            </td>
        </tr>
    </table>



</body>

</html>